/*
 * NEH.h
 *
 *  Created on: 16 Aug 2016
 *      Author: Hannah_Pinson
 */

#ifndef NEH_H_
#define NEH_H_

#include <vector>
#include "fsp.h"


using namespace std;

struct task_processingTime{
	double task;
	double procTime;
};

vector<task_processingTime> sumProcessingTimes(FSP* fsp){
	vector<task_processingTime> tasks_procTimes;
	for(int i = 0; i < fsp->getNumberOfTasks(); i++){
		double sum = 0;
		for (int m = 0; m< fsp->getNumberOfMachines(); m++){
			sum += fsp->getTime(m, i);
		}
		task_processingTime tp;
		tp.task = i;
		tp.procTime = sum;
		tasks_procTimes.push_back(tp);
	}
	return tasks_procTimes;
}


vector<task_processingTime> sortTasks(FSP* fsp){
	vector<task_processingTime>::iterator it;
	vector<task_processingTime> unsorted_tasks_pt = sumProcessingTimes(fsp);
	vector<task_processingTime> sorted_tasks_pt;

	cout << "size: " <<  unsorted_tasks_pt.size() << endl;

	// insertion sort based on total processing time
	// non-increasing order
	sorted_tasks_pt.push_back(unsorted_tasks_pt[0]);
	for (int t = 1; t < fsp->getNumberOfTasks(); t++){
		it = sorted_tasks_pt.begin();
		bool inserted = false;
		for (int i = 0; i < t; i++){
			if (unsorted_tasks_pt[t].procTime >= sorted_tasks_pt[i].procTime){
				sorted_tasks_pt.insert(it+i,unsorted_tasks_pt[t]);
				inserted = true;
				break;
			}
		}
		//if not inserted before an element, add as last
		if (!inserted)
			sorted_tasks_pt.push_back(unsorted_tasks_pt[t]);
	}

	return sorted_tasks_pt;

}


double computeEFT(long int task, long int position, long int machine, double ** earliest_finish_times){
	double EST; // earliest starting time
	double precendent_same_machine = 0;
	double precedent_previous_machine = 0;
	if (position != 0)
		precendent_same_machine = (earliest_finish_times[machine])[position-1];
	if (machine != 0)
		precedent_previous_machine = (earliest_finish_times[machine-1])[position];
	if (precendent_same_machine >= precedent_previous_machine){
		EST = precendent_same_machine;
	}
	else
		EST = precedent_previous_machine;
	double EFT = EST + fsp->getTime(machine, task);
	return EFT;
}

double computeMakespan(FSP* fsp, vector<int> sequence){
	long int machines = fsp->getNumberOfMachines();
	long int tasks = fsp->getNumberOfTasks();

	double ** earliest_finish_times;
	earliest_finish_times = new double * [machines];
	for (int i = 0; i < machines; i++){
		earliest_finish_times[i] = new double [tasks];
	}

	for (int m = 0; m < machines; m++){
		for (int p=0; p < tasks; p++){
			earliest_finish_times[m][p] = computeEFT(sequence[p], p, m, earliest_finish_times);
		}
	}

	return earliest_finish_times[machines-1][tasks-1];

}


void NEH(FSP* fsp){

	vector<task_processingTime> sorted_tasks_pt = sortTasks(fsp);

	// place the first two tasks such that the partial makespan is minimized
	vector<long int> seq1;
	vector<long int> seq2;
	seq1.push_back(sorted_tasks_pt[0].task);
	seq1.push_back(sorted_tasks_pt[1].task);
	seq2.push_back(sorted_tasks_pt[1].task);
	seq2.push_back(sorted_tasks_pt[0].task);





}




#endif /* SRC_NEH_H_ */
